
#include <functional>
#include <map>
#include <random>
#include <string>

#include "gtest/gtest.h"
#include "random/weighted_distribution.h"

namespace {
// Generates n random numbers from the distribution.
std::vector<unsigned int> GenerateNNumbers(int n,
                                           WeightedDistribution* distribution) {
  // Set up the random number generation.
  std::random_device device;
  std::mt19937 generator(device());

  WeightedDistribution::result_type (WeightedDistribution::*operator_fptr)(
      std::mt19937&) = &WeightedDistribution::operator()<std::mt19937>;
  const auto generate_one_number =
      std::bind(operator_fptr, distribution, generator);

  // Fill the vector.
  std::vector<unsigned int> result;
  std::generate_n(std::back_inserter(result), n, generate_one_number);
  return result;
}

// Generates n numbers from a 2-1 distribution and returns the ratio.
double TwoOneExperiment(int n) {
  // Create the distribution and generate the numbers.
  WeightedDistribution distribution(std::vector<double>{2, 1});
  const std::vector<unsigned int> random_numbers =
      GenerateNNumbers(n, &distribution);

  // Calculate the ratio.
  const int zeros = std::count(random_numbers.begin(), random_numbers.end(), 0);
  const int ones = random_numbers.size() - zeros;
  return zeros / static_cast<double>(ones);
}
}

TEST(WeightedDistributionTest, MainTest) {
  // Set up some constants.
  const int TEST_SIZE = 10000;
  const double ERROR_ALLOWED = 0.03;
  const int RETRIES = 5;

  bool passed = false;
  for (int i = 0; i < RETRIES; ++i) {
    // See if this experiment run passes the error threshold.
    const double TwoOneRatio = TwoOneExperiment(TEST_SIZE);
    const double error = std::abs(TwoOneRatio - 2.0);
    if (error <= ERROR_ALLOWED) {
      passed = true;
    }
  }
  if (!passed) {
    FAIL() << "The random numbers generated by the weighted distribution could "
              "not each the desired accuracy. Try rerunning the test to see if "
              "you were just unlucky. If it still fails, there might be a bug.";
  }
}

TEST(WeightedDistributionTest, FromMapTest) {
  const std::map<std::string, double> test_map{{"foo", 0.5}, {"bar", 1.0}};
  const auto distribution_map_pair = WeightedDistribution::FromMap(test_map);

  // Find the indices for "foo" and "bar".
  std::unordered_map<unsigned int, std::string> back_map =
      distribution_map_pair.second;
  ASSERT_EQ(back_map.size(), 2);
  const unsigned int foo_index = (back_map[0] == "foo" ? 0 : 1);
  const unsigned int bar_index = 1 - foo_index;
  EXPECT_EQ(back_map[foo_index], "foo");
  EXPECT_EQ(back_map[bar_index], "bar");

  // Make sure the probabilities are correct.
  const std::vector<double> distribution_weights =
      distribution_map_pair.first.param();
  EXPECT_EQ(distribution_weights[foo_index], 0.5);
  EXPECT_EQ(distribution_weights[bar_index], 1.0);
}
